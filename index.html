<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wizz NOP Brief — v8.8-ogimet-no-syntax</title>

  <!-- PDF.js (client-side PDF text extraction) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/legacy/build/pdf.min.js"></script>

  <script>
// Global error surface (so failures don't look like "nothing happens")
    window.addEventListener("error", function(ev){
      var msg = "[JS error] " + (ev.message || "Unknown") + (ev.filename ? (" @ " + ev.filename) : "");
      var el = document.getElementById("pdfStatus") || document.getElementById("buildStatus");
      if (el) el.textContent = msg;
    });

    window.addEventListener("unhandledrejection", function(ev){
      var msg = "[Promise rejection] " + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason || "Unknown"));
      var el = document.getElementById("pdfStatus") || document.getElementById("buildStatus");
      if (el) el.textContent = msg;
    });
  </script>


  <!-- DOCX export (client-side) -->
  <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <!-- PPTX export (client-side) -->
  <script src="https://unpkg.com/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>

  <style>
    :root{
      --bg: #0a0f1c;
      --panel: rgba(12, 18, 32, 0.86);
      --text: #e9eefc;
      --muted: rgba(233, 238, 252, 0.72);
      --border: rgba(255,255,255,0.12);
      --shadow: 0 12px 30px rgba(0,0,0,0.38);
      --radius: 14px;

      --wizz: #c5007a;
      --good: #2ee59d;
      --warn: #ffce3a;
      --bad: #ff4d6d;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    html, body { height:100%; margin:0; background: var(--bg); color: var(--text); font-family: var(--sans); }

    .app{
      display:grid;
      grid-template-columns: 440px 1fr;
      min-height: 100vh;
    }
    .panel{
      background: var(--panel);
      border-right: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 16px;
      position: sticky;
      top: 0;
      height: 100vh;
      overflow: auto;
    }
    .brand{
      display:flex; gap:12px; align-items:center;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(197,0,122,0.22), rgba(255,255,255,0.03));
      border-radius: 16px;
      margin-bottom: 14px;
    }
    .logo{
      width: 44px; height: 44px; border-radius: 12px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.35), rgba(255,255,255,0.05)),
                  linear-gradient(135deg, rgba(197,0,122,0.85), rgba(122,162,255,0.55));
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: 0 16px 28px rgba(0,0,0,0.35);
      position: relative;
      overflow: hidden;
    }
    .logo:after{
      content:"";
      position:absolute; inset:-40%;
      background: linear-gradient(120deg, rgba(255,255,255,0.0), rgba(255,255,255,0.22), rgba(255,255,255,0.0));
      transform: rotate(12deg);
      animation: sheen 4.5s linear infinite;
    }
    @keyframes sheen{
      0%{ transform: translateX(-35%) rotate(12deg); }
      100%{ transform: translateX(35%) rotate(12deg); }
    }
    .brand h1{
      margin:0; font-size: 15px; letter-spacing: 0.04em;
      font-weight: 900;
    }
    .brand small{ display:block; margin-top: 4px; color: var(--muted); font-weight: 650; }
    .section{
      margin-top: 12px;
      padding: 12px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
    }
    .section h3{
      margin: 0 0 10px 0;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }
    label{
      display:block;
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
      margin: 8px 0 6px;
    }
    input[type="url"], input[type="file"], textarea, select{
      width: 100%;
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.20);
      color: var(--text);
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: 12px;
      outline: none;
    }
    textarea{ min-height: 92px; resize: vertical; }

    .row{ display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .btn{
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
      letter-spacing: 0.01em;
      font-size: 13px;
      flex: 1 1 auto;
      text-align:center;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: rgba(197,0,122,0.24);
      border-color: rgba(197,0,122,0.52);
    }
    .btn.good{
      background: rgba(46,229,157,0.16);
      border-color: rgba(46,229,157,0.34);
    }
    .btn.warn{
      background: rgba(255,206,58,0.14);
      border-color: rgba(255,206,58,0.34);
    }
    .btn.danger{
      background: rgba(255,77,109,0.16);
      border-color: rgba(255,77,109,0.34);
    }

    .status{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      color: rgba(233,238,252,0.86);
      font-weight: 750;
      font-size: 12px;
      line-height: 1.35;
    }
    .hint{
      color: rgba(233,238,252,0.70);
      font-size: 12px;
      line-height: 1.45;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      padding: 6px 10px;
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-size: 11px;
      color: rgba(233,238,252,0.88);
    }
    .dot{ width:10px; height:10px; border-radius: 999px; display:inline-block; }
    .dot.good{ background: var(--good); }
    .dot.warn{ background: var(--warn); }
    .dot.bad{  background: var(--bad); }

    /* Report area */
    .report{
      padding: 22px 22px 80px;
      background: radial-gradient(1200px 600px at 25% 5%, rgba(197,0,122,0.12), rgba(10,15,28,0.0)),
                  radial-gradient(900px 520px at 85% 20%, rgba(122,162,255,0.12), rgba(10,15,28,0.0));
      overflow:auto;
    }
    .sheet{
      max-width: 1140px;
      margin: 0 auto;
      background: rgba(8,12,22,0.54);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 18px 18px 20px;
    }
    .sheetHeader{
      display:flex;
      justify-content: space-between;
      gap: 14px;
      align-items:flex-start;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      padding-bottom: 12px;
      margin-bottom: 12px;
    }
    .sheetHeader h2{
      margin:0;
      font-size: 18px;
      font-weight: 950;
      letter-spacing: 0.02em;
    }
    .sheetHeader .meta{
      text-align:right;
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(233,238,252,0.80);
      line-height: 1.35;
    }
    .kpis{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin: 12px 0;
    }
    .kpi{
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
    }
    .kpi .k{
      color: rgba(233,238,252,0.72);
      font-weight: 850;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      font-size: 11px;
    }
    .kpi .v{
      margin-top: 8px;
      font-size: 24px;
      font-weight: 950;
      letter-spacing: 0.01em;
    }
    .kpi .s{
      margin-top: 4px;
      color: rgba(233,238,252,0.70);
      font-weight: 700;
      font-size: 12px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 12px;
      margin-top: 12px;
    }
    .card{
      padding: 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
    }
    .card h4{
      margin:0 0 8px 0;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: rgba(233,238,252,0.75);
      font-weight: 900;
    }
    .bullets{
      margin: 8px 0 0 18px;
      padding:0;
      color: rgba(233,238,252,0.88);
      font-weight: 700;
      line-height: 1.45;
      font-size: 13px;
    }
    .table{
      width:100%;
      border-collapse: separate;
      border-spacing: 0;
      overflow:hidden;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
      font-family: var(--mono);
      font-size: 12px;
    }
    .table th, .table td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      vertical-align: top;
    }
    .table th{
      text-align:left;
      color: rgba(233,238,252,0.82);
      font-weight: 950;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 11px;
      background: rgba(255,255,255,0.04);
    }
    .table tr:last-child td{ border-bottom: none; }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 950;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      font-size: 11px;
      border: 1px solid rgba(255,255,255,0.14);
      white-space: nowrap;
    }
    .badge.red{ background: rgba(255,77,109,0.16); border-color: rgba(255,77,109,0.40); }
    .badge.amb{ background: rgba(255,206,58,0.14); border-color: rgba(255,206,58,0.38); }
    .badge.gre{ background: rgba(46,229,157,0.14); border-color: rgba(46,229,157,0.34); }
    .badge.base{ background: rgba(197,0,122,0.16); border-color: rgba(197,0,122,0.40); }

    .raw{
      white-space: pre-wrap;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      color: rgba(233,238,252,0.86);
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 12px;
      max-height: 340px;
      overflow:auto;
    }

    .footerNote{
      margin-top: 12px;
      color: rgba(233,238,252,0.70);
      font-size: 12px;
      line-height: 1.45;
    }

    @media (max-width: 1100px){
      .app{ grid-template-columns: 1fr; }
      .panel{ height:auto; position: relative; }
      .kpis{ grid-template-columns: 1fr 1fr; }
      .grid2{ grid-template-columns: 1fr; }
      .btn{ flex: 1 1 100%; }
    }
    @media print{
      body{ background: white; color: black; }
      .panel{ display:none !important; }
      .report{ padding: 0; background: white; }
      .sheet{ max-width: none; box-shadow: none; border: none; background: white; }
      .card{ background: white; border: 1px solid #ddd; }
      .table{ background: white; border: 1px solid #ddd; }
      .table th{ background: #f3f3f3; color: #111; }
      .raw{ background: #fafafa; color: #111; border: 1px solid #ddd; }
      .badge{ border: 1px solid #999; }
    }
  
  .modal{ position:fixed; inset:0; display:none; z-index:9999; }
  .modal[aria-hidden="false"]{ display:block; }
  .modalBackdrop{ position:absolute; inset:0; background:rgba(5,8,18,0.72); }
  .modalCard{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(980px, calc(100vw - 32px)); max-height:calc(100vh - 32px);
    background:rgba(15,18,28,0.98); border:1px solid rgba(255,255,255,0.12);
    border-radius:16px; box-shadow:0 20px 80px rgba(0,0,0,.55);
    padding:14px; display:flex; flex-direction:column; gap:10px;
  }
  .modalHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:10px; }
  .modalTitle{ font-weight:900; letter-spacing:.2px; font-size:16px; }
  .modalSub{ opacity:.8; font-size:12px; margin-top:2px; }
  #copyModalText{
    width:100%; min-height:340px; flex:1;
    border-radius:12px; border:1px solid rgba(255,255,255,0.12);
    background:rgba(9,12,20,0.92);
    color:rgba(233,238,252,0.95);
    font-family: var(--mono); font-size:12px; line-height:1.5;
    padding:12px; resize:vertical;
  }
  .modalActions{ display:flex; gap:10px; justify-content:flex-end; }

</style>

  <!-- Leaflet (map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

</head>

<body>
  <div class="app">
    <aside class="panel">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Wizz NOP Weather Brief</h1>
          <small>Client-side parsing → English management report (DOCX/PPTX export) | <span class="mono" id="verTag">v8.6-metar-compare-stable</span></small>
        </div>
      </div>

      <div class="section">
        <h3>1) Wizz network inputs</h3>
        <div class="hint">For daily use: the app auto-loads <span style="font-family:var(--mono)">wizz_icaos.txt</span> from the repo root. Manual upload is only a fallback.</div>

        <label>Wizz-relevant stations (TXT, 1 ICAO per line)</label>
        <input id="icaoFile" type="file" accept=".txt,text/plain" />
        <div class="row" style="margin-top:10px;">
          <button class="btn good" id="btnLoadIcao">Load ICAO list</button>
          <button class="btn" id="btnUseSample">Use sample list</button>
        </div>
        <div class="status" id="icaoStatus">No ICAO list loaded.</div>
        <div class="row" style="margin-top:10px;">
          <button class="btn" id="btnAutoLoad">Auto-load from repo (wizz_icaos.txt, wizz_station_map.*, wizz_core_bases.txt)</button>
        </div>


        <label style="margin-top:12px;">Optional: station names (CSV or JSON)</label>
        <div class="hint">
          CSV format: <span style="font-family:var(--mono)">ICAO,Name,Country,Type,Lat,Lon</span> (Type optional; Lat/Lon optional).<br/>
          JSON format: [{ "icao":"LHBP","name":"Budapest","country":"HU","type":"BASE","lat":47.439,"lon":19.261 }, ...]
        </div>
        <input id="mapFile" type="file" accept=".csv,application/json,text/plain" />
        <div class="row" style="margin-top:10px;">
          <button class="btn good" id="btnLoadMap">Load station mapping</button>
          <button class="btn" id="btnClearMap">Clear mapping</button>
        </div>
        <div class="status" id="mapStatus">No mapping loaded (ICAO-only display).</div>

        <label style="margin-top:12px;">Optional: core bases list (TXT, 1 ICAO per line)</label>
        <input id="baseFile" type="file" accept=".txt,text/plain" />
        <div class="row" style="margin-top:10px;">
          <button class="btn good" id="btnLoadBases">Load bases</button>
          <button class="btn" id="btnUseBaseSample">Use sample bases</button>
        </div>
        <div class="status" id="baseStatus">No base list loaded.</div>

        <div class="hint" style="margin-top:8px;">
          Tip: Put <span style="font-family:var(--mono)">wizz_icaos.txt</span> + optional mapping files in your GitHub repo and load them here daily.
        </div>
      </div>

      <div class="section">
        <h3>2) NOP PDF input</h3>
        <label>Upload the daily NOP PDF</label>
        <div class="hint">Only PDF upload is supported (URL fetch is disabled due to cross-origin restrictions).</div>
        <label style="margin-top:12px;">Or upload PDF (recommended)</label>
        <input id="pdfFile" type="file" accept="application/pdf" />
        <div class="row" style="margin-top:10px;">
          <button class="btn primary" id="btnLoadPdfFile">Load PDF from file</button>
          <button class="btn danger" id="btnClearPdf">Clear PDF</button>
        </div>

        <div class="status" id="pdfStatus">No PDF loaded.</div>
        <div class="hint" style="margin-top:8px;">
          GitHub Pages runs in-browser. If the PDF server blocks cross-origin fetch, use the file upload.
        </div>
      </div>

      <div class="section">
        <h3>3) Report generation & export</h3>

        <label>Minimum score threshold</label>
        <select id="minScore">
          <option value="0" selected>0 (include all)</option>
          <option value="3">3 (reduce noise)</option>
          <option value="5">5 (medium+ only)</option>
          <option value="7">7 (RED only)</option>
        </select>

        <label style="margin-top:10px;">Max hotspots</label>
        <select id="maxHot">
          <option value="10">10</option>
          <option value="15" selected>15</option>
          <option value="20">20</option>
        </select>

        <div class="row" style="margin-top:12px;">
          <button class="btn good" id="btnBuild">Build report</button>
          <button class="btn warn" id="btnCopy">Copy meeting summary</button>
        </div>
        <div class="row" style="margin-top:10px;">
          <button class="btn" id="btnPrint">Print / Save as PDF</button>
          <button class="btn" id="btnDocx">Export DOCX</button>
          <button class="btn" id="btnPptx">Export PPTX (1 slide)</button>
        </div>

        <div class="status" id="buildStatus">Ready. (JS loading…)</div>

        <div class="section" style="margin-top:12px;">
          <h3>Severity legend</h3>
          <div class="row">
            <span class="pill"><span class="dot bad"></span>RED (high disruption)</span>
            <span class="pill"><span class="dot warn"></span>AMBER (medium)</span>
            <span class="pill"><span class="dot good"></span>GREEN (low)</span>
          </div>
        </div>

        <div class="hint" style="margin-top:10px;">
          “Delay risk” is an evidence-based heuristic derived from drivers (winter/CB/wind/low-vis) and intensity signals (e.g., gusts, +TS, FZRA).
        </div>
      </div>
    </aside>

    <main class="report">
      <div class="sheet" id="reportSheet">
        <div class="sheetHeader">
          <div>
            <h2 id="rTitle">Wizz Air — NOP Weather / Delay Risk Brief</h2>
            <div style="margin-top:6px; color:rgba(233,238,252,0.78); font-weight:700;">
              Daily, Wizz-filtered overview of likely disruption drivers.
            </div>
          </div>
          <div class="meta">
            <div><strong>Generated:</strong> <span id="rGenerated">—</span></div>
            <div><strong>Source:</strong> <span id="rSource">—</span></div>
            <div><strong>Stations loaded:</strong> <span id="rStations">0</span></div>
            <div><strong>Mapping:</strong> <span id="rMapping">—</span></div>
          </div>
        </div>

        <div class="kpis">
          <div class="kpi">
            <div class="k">Matched stations</div>
            <div class="v" id="kMatched">0</div>
            <div class="s">Airports Overview ∩ Wizz ICAO (after threshold)</div>
          </div>
          <div class="kpi">
            <div class="k">RED</div>
            <div class="v" id="kRed">0</div>
            <div class="s">High disruption risk</div>
          </div>
          <div class="kpi">
            <div class="k">AMBER</div>
            <div class="v" id="kAmber">0</div>
            <div class="s">Medium risk</div>
          </div>
          <div class="kpi">
            <div class="k">Primary drivers</div>
            <div class="v" id="kDrivers">—</div>
            <div class="s">Winter / Wind / Convective / Low-vis</div>
          </div>
        </div>

        <div class="grid2">
          <div class="card">
            <h4>Executive summary</h4>
            <ul class="bullets" id="execBullets">
              <li>Load your ICAO list and the daily NOP PDF, then build the report.</li>
              <li>If URL fetch fails due to CORS, use file upload.</li>
              <li>This is a leadership summary, not a substitute for validated operational MET inputs.</li>
            </ul>
          </div>
          <div class="card">
            <h4>Recommended operational posture</h4>
            <ul class="bullets" id="recoBullets">
              <li>Winter ops: de-icing readiness; protect turnarounds at exposed stations; review alternates.</li>
              <li>Wind/CB windows: anticipate approach limits; holding/diversion sensitivity; capacity variability.</li>
              <li>Network: monitor ATFM/capacity; protect critical rotations and first-wave performance.</li>
            </ul>
          </div>
        </div>

        <div class="card" style="margin-top:12px;">
          <h4>Affected Wizz airports (most relevant)</h4>
          <div style="overflow:auto;">
            <table class="table" id="hotTable">
              <thead>
                <tr>
                  <th>Severity</th>
                  <th>Delay risk</th>
                  <th>ICAO</th>
                  <th>Station</th>
                  <th>Time</th>
                  <th>Drivers</th>
                  <th>Plain-language</th>
                  <th>Snippet</th>
                </tr>
              </thead>
              <tbody id="hotBody">
                <tr><td colspan="8" style="color:rgba(233,238,252,0.70); font-weight:700;">No data.</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        
        <div class="grid2" style="margin-top:12px;">
          <div class="card">
            <h4>Map view (hotspots)</h4>
            <div class="hint" style="margin-bottom:8px;">
              The map uses auto-resolved airport coordinates from a public dataset. If your corporate network blocks external datasets or map tiles, markers may not display.
            </div>
            <div id="map" style="height:360px; border-radius:14px; border:1px solid rgba(255,255,255,0.10); overflow:hidden;"></div>
          </div>
          <div class="card">
            <h4>Management readout (30–60s script)</h4>
            <div class="row" style="margin-top:10px; gap:8px;">
              <button class="btn" id="btnCopilot">Copy Copilot prompt (rewrite script)</button>
            </div>
            <div class="raw" id="readoutBox">—</div>
            <div class="hint" style="margin-top:8px;">
              This script is generated from the extracted NOP synopsis + Wizz-filtered hotspots. It is deterministic (no external AI calls) and safe to read verbatim.
            </div>
          </div>
        </div>

<div class="card" style="margin-top:12px;">
          <h4>Airspace / en-route notes (extracted)</h4>
          <div class="raw" id="enrouteBox">—</div>
        </div>

        <div class="card" style="margin-top:12px;">
          <h4>Weather synopsis (extracted)</h4>
          <div class="raw" id="synopsisBox">—</div>
        </div>

        
        <div class="card" style="margin-top:12px;">
          <h4>Raw 'Airports Overview' section (extracted)</h4>
          <div class="raw" id="airportsOverviewBox">—</div>
        </div>

<div class="card" style="margin-top:12px;">
          <h4>Parsing diagnostics</h4>
          <div class="raw" id="debugBox">Ready.</div>
        </div>

        <div class="footerNote">
          Disclaimer: leadership summary for situational awareness. For operational decisions, use validated MET/ATM sources and company procedures.
        </div>
      </div>
    <div style="opacity:.6; font-size:12px; padding:10px 2px;">Version: <span class="mono" id="verFooter">v8.6-metar-compare-stable</span></div>
<div class="footerVersion">Version: <span class="mono">v8.8-ogimet-no-syntax</span></div>
</main>
  </div>

<script>
  // PDF.js worker
  pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/legacy/build/pdf.worker.min.js";

  // State
  let WIZZ_ICAOS = new Set();
  let CORE_BASES = new Set();
  let STATION_MAP = new Map(); // ICAO -> {name,country,type}
  let PDF_TEXT = "";
  let PDF_SOURCE = "";
  let LAST_MATCHED = [];
  let LAST_SYNOPSIS = "";
  let LAST_ENROUTE = "";
  let LAST_READOUT = "";

  let PDF_LOADED_AT = null;

  const SAMPLE_ICAOS = [
    "LHBP","LOWW","LKPR","EPWA","EPGD","EDDH","EDDF","EDDM","EHAM","LFPG","LIRF","LEBL","LPPT","LPMA",
    "LROP","LBSF","LTFM","LGAV","LCLK","GCLP","GMMN"
  ];
  const SAMPLE_BASES = ["LHBP","EPWA","LTFM","LGAV","LBSF","LROP"];

  // Helpers
  const $ = (id) => document.getElementById(id);

  

  async function tryCopyText(text){
    if (navigator.clipboard && navigator.clipboard.writeText){
      try{ await navigator.clipboard.writeText(text); return true; } catch(e){}
    }
    try{
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly","readonly");
      ta.style.position = "fixed";
      ta.style.top = "-9999px";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return !!ok;
    } catch(e){
      return false;
    }
  }

  function openCopyModal(text){
    const modal = $("copyModal");
    const ta = $("copyModalText");
    if (!modal || !ta) return;
    ta.value = text;
    modal.setAttribute("aria-hidden","false");
    setTimeout(() => { ta.focus(); ta.select(); }, 50);
  }

  function closeCopyModal(){
    const modal = $("copyModal");
    if (!modal) return;
    modal.setAttribute("aria-hidden","true");
  }
function nowLocal(){
    const d = new Date();
    const pad = (n) => String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }
  function todayUtcYmd(){
    const d = new Date();
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth()+1).padStart(2,"0");
    const day = String(d.getUTCDate()).padStart(2,"0");
    return `${y}${m}${day}`;
  }
  function setStatus(id, msg){ $(id).textContent = msg; }
  function escapeHtml(s){
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }
  function uniq(arr){ return [...new Set(arr)]; }

  function parseIcaoText(text){
    const out = [];
    const lines = text.split(/\r?\n/).map(l => l.trim().toUpperCase()).filter(Boolean);
    for (const l of lines){
      const m = l.match(/\b[A-Z]{4}\b/);
      if (m) out.push(m[0]);
    }
    return uniq(out);
  }

  
  function parseCsvMapping(text){
    // ICAO,Name,Country,Type,Lat,Lon
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const out = [];
    for (const line of lines){
      if (/^ICAO\b/i.test(line)) continue;
      const parts = line.split(",").map(x => x.trim());
      if (parts.length < 2) continue;
      const icao = (parts[0] || "").toUpperCase();
      if (!/^[A-Z]{4}$/.test(icao)) continue;

      const lat = parts.length >= 5 ? parseFloat(parts[4]) : NaN;
      const lon = parts.length >= 6 ? parseFloat(parts[5]) : NaN;

      out.push({
        icao,
        name: parts[1] || "",
        country: parts[2] || "",
        type: (parts[3] || "").toUpperCase(),
        lat: Number.isFinite(lat) ? lat : null,
        lon: Number.isFinite(lon) ? lon : null
      });
    }
    return out;
  }

  async function readFileText(file){ return await file.text(); }

  // PDF extraction: rebuild "lines" by Y coordinate
  async function extractTextFromPdfArrayBuffer(buf){
    if (!window.pdfjsLib) throw new Error("PDF.js library failed to load (CDN blocked).");
    const doc = await pdfjsLib.getDocument({ data: buf }).promise;
    let full = [];
    for (let p=1; p<=doc.numPages; p++){
      const page = await doc.getPage(p);
      const content = await page.getTextContent();
      const items = content.items
        .filter(it => it.str && it.str.trim().length)
        .map(it => ({ str: it.str, x: it.transform[4], y: it.transform[5] }))
        .sort((a,b) => (b.y - a.y) || (a.x - b.x));

      let line = [];
      let currentY = null;

      const flush = () => {
        if (!line.length) return;
        // Join with spacing; small heuristic to reduce over-joining
        const s = line.map(x => x.str).join(" ").replace(/\s+/g," ").trim();
        if (s) full.push(s);
        line = [];
      };

      for (const it of items){
        if (currentY === null) currentY = it.y;
        if (Math.abs(it.y - currentY) > 2.6){
          flush();
          currentY = it.y;
        }
        line.push(it);
      }
      flush();
      full.push("");
    }
    return full.join("\n");
  }

    // NOP-specific parsing (heuristics)
  function extractSection(text, startLabel, endLabels){
    const t = text.replace(/\r/g, "");
    const idx = t.toLowerCase().indexOf(startLabel.toLowerCase());
    if (idx < 0) return "";
    let end = t.length;
    for (const e of endLabels){
      const j = t.toLowerCase().indexOf(e.toLowerCase(), idx + startLabel.length);
      if (j >= 0) end = Math.min(end, j);
    }
    return t.slice(idx, end).trim();
  }

  function extractSynopsis(text){
    const endLabels = ["Airports Overview", "AIRPORTS OVERVIEW", "En-route", "En route", "En-Route"];
    let sec = extractSection(text, "Synopsis", endLabels);
    if (sec) return sec;
    sec = extractSection(text, "SYNOPSIS", endLabels);
    if (sec) return sec;
    const ao = text.toLowerCase().indexOf("airports overview");
    if (ao > 0) return text.slice(0, Math.min(ao, 2600)).trim();
    return text.slice(0, 2600).trim();
  }

  function extractEnroute(text){
    // Capture en-route related paragraphs for ATM impact cues (CAT, CB tops, jet, etc.)
    const sec = extractSection(text, "En-route", ["Disclaimer", "Legend", "Definitions", "Airports Overview"]);
    if (sec) return sec;
    const sec2 = extractSection(text, "En route", ["Disclaimer", "Legend", "Definitions", "Airports Overview"]);
    if (sec2) return sec2;
    // Fallback: try to locate "CAT" and take a slice
    const idx = text.toUpperCase().indexOf("CAT");
    if (idx > 0) return text.slice(Math.max(0, idx-600), Math.min(text.length, idx+1200)).trim();
    return "";
  }

  function parseAirportsOverview(text){
    const sec = extractSection(text, "Airports Overview", ["En-route", "En route", "En-Route", "Disclaimer", "Legend", "Definitions"]);
    const block = sec || text;

    // Preferred: item starts on a new line: ICAO + time-window (e.g. 0106/0110)
    const re = /(\b[A-Z]{4}\b)\s+(\d{4}\/\d{4})\s+([\s\S]*?)(?=\n[A-Z]{4}\s+\d{4}\/\d{4}\s+|\n\s*$)/g;
    let m;
    const items = [];
    while ((m = re.exec(block)) !== null){
      items.push({
        icao: m[1].trim(),
        time: m[2].trim(),
        snippet: m[3].replace(/\s+/g," ").trim(),
        raw: `${m[1].trim()} ${m[2].trim()} ${m[3].replace(/\s+/g," ").trim()}`
      });
    }

    // Fallback: if newlines collapsed
    if (!items.length){
      const flat = block.replace(/\n+/g," ").replace(/\s+/g," ");
      const re2 = /(\b[A-Z]{4}\b)\s+(\d{4}\/\d{4})\s+(.+?)(?=\s+[A-Z]{4}\s+\d{4}\/\d{4}\s+|$)/g;
      while ((m = re2.exec(flat)) !== null){
        items.push({ icao: m[1], time: m[2], snippet: m[3].trim(), raw: `${m[1]} ${m[2]} ${m[3].trim()}` });
      }
    }
    

    // Extra fallback: scan within Airports Overview section for known ICAOs and capture a nearby window
    // This helps when PDF line breaks / ordering are heavily distorted.
    if (items.length < 3){
      try{
        const sec2 = extractSection(text, "Airports Overview", ["En-route", "En route", "En-Route", "Disclaimer", "Legend", "Definitions"]);
        const hay = (sec2 || "").replace(/\s+/g," ").trim();
        if (hay){
          const found = new Map(); // icao -> best snippet
          // Collect all ICAO-like tokens with their position
          const reIcao = /\b[A-Z]{4}\b/g;
          let mm;
          while ((mm = reIcao.exec(hay)) !== null){
            const icao = mm[0];
            // Take a window after the ICAO token
            const start = mm.index;
            const windowText = hay.slice(start, Math.min(hay.length, start + 180));
            // Expect time window close by
            const tm = windowText.match(/\b(\d{4}\/\d{4})\b/);
            const time = tm ? tm[1] : "";
            // Stop at the next ICAO token to avoid bleeding
            const next = windowText.slice(5).search(/\b[A-Z]{4}\b\s+\d{4}\/\d{4}\b/);
            const snippet = (next > 0 ? windowText.slice(0, 5 + next) : windowText).replace(/\s+/g," ").trim();
            if (!found.has(icao) || (found.get(icao).snippet.length < snippet.length)){
              found.set(icao, { icao, time: time || "—", snippet: snippet.replace(/^([A-Z]{4}\s+)/, "").replace(/^\d{4}\/\d{4}\s+/, ""), raw: snippet });
            }
          }
          // Replace items with this broader set if it helps
          const broader = Array.from(found.values())
            .filter(x => /^[A-Z]{4}$/.test(x.icao) && x.snippet && x.snippet.length > 6);
          if (broader.length > items.length){
            return broader;
          }
        }
      } catch(e){
        // ignore
      }
    }
return items;
  }

  // Global fallback: parse any "ICAO + time window + snippet" patterns anywhere in the extracted PDF text.
  // This is necessary when the "Airports Overview" is embedded as an image/table and therefore not extractable as text.
  function parseGlobalIcaoItems(text){
    const t = text.replace(/\r/g,"");
    // Prefer line-based parsing first
    const lines = t.split("\n").map(x => x.trim()).filter(Boolean);
    const items = [];

    // Pattern like: EHAM 0106/0111 25020G30KT ... or EGSS 0116/0124 29017G27KT
    const reLine = /^([A-Z]{4})\s+(\d{4}\/\d{4})\s+(.{8,})$/;

    for (const line of lines){
      const m = line.match(reLine);
      if (m){
        items.push({
          icao: m[1],
          time: m[2],
          snippet: m[3].replace(/\s+/g," ").trim(),
          raw: line
        });
      }
    }

    // If line-based fails (common when PDF collapses lines), use a flat scan.
    if (items.length < 3){
      const flat = t.replace(/\n+/g," ").replace(/\s+/g," ").trim();
      const re = /(\b[A-Z]{4}\b)\s+(\d{4}\/\d{4})\s+(.+?)(?=\s+\b[A-Z]{4}\b\s+\d{4}\/\d{4}\b\s+|$)/g;
      let mm;
      while ((mm = re.exec(flat)) !== null){
        const icao = mm[1];
        const time = mm[2];
        const snippet = (mm[3] || "").trim();
        if (snippet.length < 8) continue;
        items.push({ icao, time, snippet, raw: `${icao} ${time} ${snippet}` });
      }
    }

    // De-dup by ICAO+time+snippet
    const seen = new Set();
    const out = [];
    for (const it of items){
      const k = `${it.icao}|${it.time}|${it.snippet}`;
      if (seen.has(k)) continue;
      seen.add(k);
      out.push(it);
    }
    return out;
  }


  // Risk tagging / scoring (heuristic)
  
  // Plain-language decoder for common aviation weather tokens
  function explainSnippet(raw){
    const s = String(raw || "").toUpperCase();
    const parts = [];

    // Wind e.g. 25020G30KT
    const w = s.match(/\b(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT\b/);
    if (w){
      const dir = w[1] === "VRB" ? "variable" : `${w[1]}°`;
      const spd = parseInt(w[2],10);
      const gust = w[4] ? parseInt(w[4],10) : null;
      parts.push(gust ? `Wind ${dir} ${spd} kt gusting ${gust} kt` : `Wind ${dir} ${spd} kt`);
    }

    // Low visibility cues
    if (/\bFZFG\b/.test(s)) parts.push("Freezing fog (very low visibility, icing risk)");
    else if (/\bFG\b/.test(s)) parts.push("Fog / very low visibility");
    if (/\bBR\b/.test(s) && !/\bFZFG\b/.test(s)) parts.push("Mist / reduced visibility");

    // Precip / winter
    if (/\bFZRA\b/.test(s)) parts.push("Freezing rain (high icing / ground ops impact)");
    if (/\bBLSN\b/.test(s)) parts.push("Blowing snow (drifting, low vis)");
    if (/\+SN\b/.test(s)) parts.push("Heavy snow");
    else if (/\bSN\b/.test(s)) parts.push("Snow");
    if (/\bRASN\b/.test(s)) parts.push("Rain and snow mix");
    if (/\+RA\b/.test(s)) parts.push("Heavy rain");
    else if (/\bRA\b/.test(s) || /\bSHRA\b/.test(s)) parts.push("Rain / showers");

    // Convective
    if (/\bTS\b/.test(s) || /\+TS/.test(s)) parts.push("Thunderstorms (tactical delays/diversions possible)");
    if (/\bCB\b/.test(s)) parts.push("Cumulonimbus / embedded convection possible");

    // Icing / low cloud hints
    if (/\bVV(\d{3})\b/.test(s)){
      const vv = s.match(/\bVV(\d{3})\b/);
      if (vv) parts.push(`Very low cloud (vertical visibility ${vv[1]}×100 ft)`);
    }

    // If nothing found, return a short generic
    if (!parts.length) return "Adverse weather signalled in NOP text (see raw snippet).";
    // Reduce to 2–3 most important points for lay audience
    return parts.slice(0,3).join("; ");
  }

function scoreAndTag(item){
    const s = (item.raw || "").toUpperCase();
    let score = 0;
    const tags = [];

    // Convective
    if (/\bTS\b/.test(s) || /\+TS/.test(s) || /\bCB\b/.test(s)){
      score += 4; tags.push("CONVECTIVE");
    }

    // Winter
    if (/\bFZRA\b/.test(s)){ score += 5; tags.push("FZRA"); }
    if (/\bBLSN\b/.test(s) || /\bDRSN\b/.test(s)){ score += 4; tags.push("BLOWING/DRIFT SN"); }
    if (/\+SN\b/.test(s)){ score += 4; tags.push("HEAVY SN"); }
    else if (/\bSN\b/.test(s)){ score += 3; tags.push("SN"); }

    // Low visibility / fog
    if (/\bFZFG\b/.test(s) || /\bFG\b/.test(s)){ score += 4; tags.push("FOG"); }
    if (/\bBR\b/.test(s) && !/\bFZRA\b/.test(s)){ score += 1; tags.push("BR"); }
    if (/\b(0\d{3}|1\d{3})\b/.test(s)){ // crude: very low vis numbers sometimes appear
      score += 1; tags.push("LOW VIS");
    }

    // Wind / gusts
    const gust = s.match(/G(\d{2,3})KT/);
    if (gust){
      const g = parseInt(gust[1],10);
      if (g >= 45) score += 4;
      else if (g >= 35) score += 3;
      else if (g >= 28) score += 2;
      else score += 1;
      tags.push("WIND GUSTS");
    } else {
      const wind = s.match(/\b(\d{3}|VRB)\d{2,3}KT\b/);
      if (wind){ score += 1; tags.push("WIND"); }
    }

    // Precip intensity
    if (/\+RA\b/.test(s) || /\bSHRA\b/.test(s) || /\bSHSNRA\b/.test(s)){ score += 2; tags.push("HEAVY PRECIP"); }
    else if (/\bRA\b/.test(s) || /\bSH\b/.test(s)){ score += 1; tags.push("PRECIP"); }

    // Interaction bonus
    if (tags.includes("CONVECTIVE") && (tags.includes("WIND GUSTS") || tags.includes("WIND"))) score += 1;
    if (tags.includes("FZRA") && (tags.includes("WIND GUSTS") || tags.includes("WIND"))) score += 1;

    // Core base weighting (disruption propagates)
    const isBase = CORE_BASES.has(item.icao);
    if (isBase) score += 1;

    score = Math.min(score, 10);

    let sev = "GREEN";
    if (score >= 7) sev = "RED";
    else if (score >= 4) sev = "AMBER";

    const delayRisk = (sev === "RED") ? "HIGH" : (sev === "AMBER" ? "MEDIUM" : "LOW");
    return { score, sev, tags: uniq(tags), delayRisk, isBase };
  }

  function driversFromItems(items){
    const cnt = { conv:0, wind:0, winter:0, lowvis:0 };
    for (const it of items){
      const t = it.tags || [];
      if (t.includes("CONVECTIVE")) cnt.conv++;
      if (t.includes("WIND GUSTS") || t.includes("WIND")) cnt.wind++;
      if (t.includes("SN") || t.includes("HEAVY SN") || t.includes("BLOWING/DRIFT SN") || t.includes("FZRA")) cnt.winter++;
      if (t.includes("FOG") || t.includes("LOW VIS")) cnt.lowvis++;
    }
    const parts = [];
    if (cnt.winter) parts.push("Winter");
    if (cnt.wind) parts.push("Wind");
    if (cnt.conv) parts.push("Convective");
    if (cnt.lowvis) parts.push("Low-vis");
    return parts.length ? parts.join(" / ") : "—";
  }

  function stationLabel(icao){
    const m = STATION_MAP.get(icao);
    if (!m){
      const info = ICAO_INFO.get(icao);
      const cached = ICAO_COORDS.get(icao);
      const station = info && (info.city || info.name) ? `${info.city || ""}${(info.city && info.name) ? " — " : ""}${info.name || ""}`.trim() : "—";
      const country = info && info.country ? info.country : "—";
      return { station, country, type: "", lat: cached ? cached.lat : null, lon: cached ? cached.lon : null };
    }
    const station = m.name || "—";
    const country = m.country || "—";
    const type = (m.type || "").toUpperCase();
    const lat0 = (typeof m.lat === "number" ? m.lat : null);
    const lon0 = (typeof m.lon === "number" ? m.lon : null);
    const cached = ICAO_COORDS.get(icao);
    return { station, country, type, lat: (lat0 !== null ? lat0 : (cached ? cached.lat : null)), lon: (lon0 !== null ? lon0 : (cached ? cached.lon : null)) };
  }

  function buildExecutiveBullets(matched){
    const bullets = [];
    const reds = matched.filter(x => x.sev === "RED").length;
    const ambs = matched.filter(x => x.sev === "AMBER").length;
    const basesHit = matched.filter(x => x.isBase).map(x => x.icao);

    if (!matched.length){
      bullets.push("No Wizz-matching items found in Airports Overview at the selected threshold.");
      return bullets;
    }

    const top = matched.slice(0, 6);
    const topTxt = top.map(x => {
      const st = stationLabel(x.icao);
      const name = st.station !== "—" ? ` — ${st.station}` : "";
      return `${x.icao}${name} (${x.sev}/${x.delayRisk}; ${x.tags.slice(0,2).join("/") || "—"})`;
    }).join("; ");
    bullets.push(`Top impacted stations: ${topTxt}.`);

    if (reds){
      bullets.push(`RED disruption risk present at ${reds} station(s). Expect elevated reactionary delay potential and rotation knock-on risk.`);
    } else {
      bullets.push("No RED-level stations at the current threshold; expect localized variability rather than network-wide disruption.");
    }

    if (ambs){
      bullets.push(`${ambs} AMBER station(s) suggest moderate capacity/ground variability; protect critical turns where feasible.`);
    }

    const drv = driversFromItems(matched);
    bullets.push(`Primary disruption drivers: ${drv}.`);

    if (basesHit.length){
      bullets.push(`Core base exposure detected: ${uniq(basesHit).slice(0,10).join(", ")}. Prioritize base protection and wave integrity.`);
    }

    return bullets;
  }

  // Copy summary
  
  function buildCopilotPrompt(){
    const rows = Array.from(document.querySelectorAll("#hotspotsTbody tr")).map(tr => {
      const tds = tr.querySelectorAll("td");
      if (tds.length < 8) return null;
      const sev = tds[0].innerText.trim();
      const risk = tds[1].innerText.trim();
      const icao = tds[2].innerText.trim().split(/\s+/)[0];
      const station = tds[3].innerText.trim();
      const time = tds[4].innerText.trim();
      const drivers = tds[5].innerText.trim();
      const plain = tds[6].innerText.trim();
      const snip = tds[7].innerText.trim();
      return { sev, risk, icao, station, time, drivers, plain, snip };
    }).filter(Boolean);

    const synopsis = (document.getElementById("synopsisBox")?.textContent || "").trim();
    const enroute = (document.getElementById("enrouteBox")?.textContent || "").trim();

    const top = rows.slice(0, 8).map(r => `- ${r.icao} (${r.station || "—"}) | ${r.sev}/${r.risk} | ${r.time} | ${r.drivers} | ${r.plain} | ${r.snip}`).join("\n");

    return [
      "Rewrite a 30–60 second executive meeting script in clear business English.",
      "Audience: airline senior management (non-technical). Tone: concise, confident, actionable.",
      "Requirements:",
      "• Mention 3–6 most relevant airports by name and ICAO, grouped by severity (RED first).",
      "• Include 1 line on network-wide drivers.",
      "• End with 3 concrete actions for OCC/Network Control.",
      "",
      "Context (NOP extracted):",
      `Synopsis: ${synopsis || "—"}`,
      `En-route notes: ${enroute || "—"}`,
      "",
      "Wizz-relevant hotspots (top):",
      top || "—",
    ].join("\n");
  }

  async function copyCopilotPrompt(){
    const prompt = buildCopilotPrompt();
    const ok = await tryCopyText(prompt);
    if (ok){
      setStatus("buildStatus", "Copied: Copilot prompt (paste into Copilot).");
    } else {
      setStatus("buildStatus", "Clipboard blocked: opened copy window for manual copy.");
      openCopyModal(prompt);
    }
  }

async function copyMeetingSummary(){
    const execLis = Array.from($("execBullets").querySelectorAll("li")).map(li => "- " + li.innerText);
    const topRows = Array.from($("hotBody").querySelectorAll("tr")).slice(0, 10).map(tr => {
      const tds = tr.querySelectorAll("td");
      if (tds.length < 8) return null;
      const sev = tds[0].innerText.split("\n")[0].trim();
      const risk = tds[1].innerText.split("\n")[0].trim();
      const icao = tds[2].innerText.trim();
      const station = tds[3].innerText.trim();
      const time = tds[4].innerText.trim();
      const drivers = tds[5].innerText.trim();
      const plain = tds[6].innerText.trim();
      const snip = tds[7].innerText.trim();
      return `- ${icao} | ${sev}/${risk} | ${time} | ${drivers} | ${station} | ${plain} | ${snip}`;
    }).filter(Boolean);

    const text = [
      $("rTitle").textContent,
      `Generated: ${$("rGenerated").textContent}`,
      `Source: ${PDF_SOURCE || "—"}`,
      "",
      "Executive summary:",
      ...execLis,
      "",
      "Top hotspots:",
      ...(topRows.length ? topRows : ["- (no data)"]),
    ].join("\n");

    await navigator.clipboard.writeText(text);
    setStatus("buildStatus", "Meeting summary copied to clipboard.");
  }

  // Export DOCX
  async function exportDocx(){
    if (!$("rGenerated").textContent || $("rGenerated").textContent === "—"){
      setStatus("buildStatus", "Build the report first.");
      return;
    }
    try{
      const docx = window.docx;
      const { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, WidthType } = docx;

      const title = $("rTitle").textContent;
      const gen = $("rGenerated").textContent;
      const src = PDF_SOURCE || "—";

      const exec = Array.from($("execBullets").querySelectorAll("li")).map(li => li.innerText);
      const reco = Array.from($("recoBullets").querySelectorAll("li")).map(li => li.innerText);
      const synopsis = $("synopsisBox").textContent || "";
      const enroute = $("enrouteBox").textContent || "";

      // Table rows
      const rows = Array.from($("hotBody").querySelectorAll("tr")).map(tr => {
        const tds = tr.querySelectorAll("td");
        if (tds.length < 8) return null;
        return Array.from(tds).map(td => td.innerText.replace(/\s+/g," ").trim());
      }).filter(Boolean);

      const makeCell = (text) => new TableCell({
        children: [new Paragraph({ children: [new TextRun({ text: text || "" })] })],
      });

      const tableRows = [
        new TableRow({
          children: ["Severity","Delay risk","ICAO","Station","Time","Drivers","Plain-language","Snippet"].map(h =>
            new TableCell({
              children: [new Paragraph({ children:[ new TextRun({ text:h, bold:true }) ] })],
            })
          )
        }),
        ...rows.map(r => new TableRow({ children: r.map(c => makeCell(c)) }))
      ];

      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            new Paragraph({ text: title, heading: HeadingLevel.HEADING_1 }),
            new Paragraph({ children: [new TextRun({ text: `Generated: ${gen} | Source: ${src}`, italics: true })] }),
            new Paragraph({ text: "Executive summary", heading: HeadingLevel.HEADING_2 }),
            ...exec.map(x => new Paragraph({ text: "• " + x })),
            new Paragraph({ text: "Recommended operational posture", heading: HeadingLevel.HEADING_2 }),
            ...reco.map(x => new Paragraph({ text: "• " + x })),
            new Paragraph({ text: "Affected Wizz airports (most relevant)", heading: HeadingLevel.HEADING_2 }),
            new Table({ rows: tableRows, width: { size: 100, type: WidthType.PERCENTAGE } }),
            new Paragraph({ text: "Airspace / en-route notes (extracted)", heading: HeadingLevel.HEADING_2 }),
            new Paragraph({ text: enroute }),
            new Paragraph({ text: "Weather synopsis (extracted)", heading: HeadingLevel.HEADING_2 }),
            new Paragraph({ text: synopsis }),
            new Paragraph({ text: "Disclaimer: leadership summary for situational awareness. Operational decisions require validated MET/ATM sources and company procedures.", spacing: { before: 240 } }),
          ]
        }]
      });

      const blob = await Packer.toBlob(doc);
      saveAs(blob, `wizz_nop_weather_brief_${todayUtcYmd()}.docx`);
      setStatus("buildStatus", "DOCX exported.");
    } catch(e){
      console.error(e);
      setStatus("buildStatus", "DOCX export failed (browser/library blocked). Use Print/PDF as fallback.");
    }
  }

  // Export PPTX (1 slide)
  async function exportPptx(){
    if (!$("rGenerated").textContent || $("rGenerated").textContent === "—"){
      setStatus("buildStatus", "Build the report first.");
      return;
    }
    try{
      const pptx = new PptxGenJS();
      pptx.layout = "LAYOUT_WIDE";
      const slide = pptx.addSlide();

      // Background
      slide.background = { color: "0A0F1C" };

      // Header bar
      slide.addShape(pptx.ShapeType.roundRect, { x:0.3, y:0.25, w:12.7, h:0.7, fill:{ color:"1A1730", transparency: 10 }, line:{ color:"FFFFFF", transparency: 85 } });
      slide.addText($("rTitle").textContent, { x:0.5, y:0.35, w:12.3, h:0.4, fontFace:"Calibri", fontSize:20, bold:true, color:"FFFFFF" });
      slide.addText(`Generated: ${$("rGenerated").textContent} | Source: ${PDF_SOURCE || "—"}`, { x:0.5, y:0.72, w:12.3, h:0.25, fontFace:"Consolas", fontSize:10, color:"CFCFEA" });

      // Executive summary box
      slide.addShape(pptx.ShapeType.roundRect, { x:0.3, y:1.15, w:7.2, h:3.25, fill:{ color:"141A2D", transparency: 10 }, line:{ color:"FFFFFF", transparency: 88 } });
      slide.addText("EXECUTIVE SUMMARY", { x:0.5, y:1.28, w:6.8, h:0.3, fontFace:"Calibri", fontSize:12, bold:true, color:"CFCFEA" });

      const exec = Array.from($("execBullets").querySelectorAll("li")).map(li => "• " + li.innerText);
      slide.addText(exec.join("\n"), { x:0.5, y:1.6, w:6.9, h:2.7, fontFace:"Calibri", fontSize:14, color:"FFFFFF", valign:"top" });

      // Hotspots box
      slide.addShape(pptx.ShapeType.roundRect, { x:7.65, y:1.15, w:5.35, h:6.7, fill:{ color:"141A2D", transparency: 10 }, line:{ color:"FFFFFF", transparency: 88 } });
      slide.addText("TOP HOTSPOTS", { x:7.85, y:1.28, w:5.0, h:0.3, fontFace:"Calibri", fontSize:12, bold:true, color:"CFCFEA" });

      const rows = Array.from($("hotBody").querySelectorAll("tr")).slice(0, 9).map(tr => {
        const tds = tr.querySelectorAll("td");
        if (tds.length < 8) return null;
        const sev = tds[0].innerText.split("\n")[0].trim();
        const risk = tds[1].innerText.split("\n")[0].trim();
        const icao = tds[2].innerText.trim();
        const time = tds[4].innerText.trim();
        const drv = tds[5].innerText.trim().split(",").slice(0,2).join(",");
        return `${icao} | ${sev}/${risk} | ${time} | ${drv}`;
      }).filter(Boolean);

      slide.addText(rows.length ? rows.join("\n") : "(no data)", { x:7.85, y:1.58, w:5.0, h:6.1, fontFace:"Consolas", fontSize:11, color:"FFFFFF", valign:"top" });

      // Recommendations box
      slide.addShape(pptx.ShapeType.roundRect, { x:0.3, y:4.55, w:7.2, h:3.3, fill:{ color:"141A2D", transparency: 10 }, line:{ color:"FFFFFF", transparency: 88 } });
      slide.addText("RECOMMENDED POSTURE", { x:0.5, y:4.68, w:6.8, h:0.3, fontFace:"Calibri", fontSize:12, bold:true, color:"CFCFEA" });
      const reco = Array.from($("recoBullets").querySelectorAll("li")).map(li => "• " + li.innerText);
      slide.addText(reco.join("\n"), { x:0.5, y:5.0, w:6.9, h:2.75, fontFace:"Calibri", fontSize:13, color:"FFFFFF", valign:"top" });

      await pptx.writeFile({ fileName: `wizz_nop_weather_brief_${todayUtcYmd()}.pptx` });
      setStatus("buildStatus", "PPTX exported.");
    } catch(e){
      console.error(e);
      setStatus("buildStatus", "PPTX export failed (browser/library blocked). Use Print/PDF as fallback.");
    }
  }

  // Build report
  
  
  // --- Airport coordinates (auto-resolve)
  // Uses OurAirports CSV (public dataset) via raw.githubusercontent.com.
  // Caches a small lookup map in localStorage to avoid repeated downloads.
  let ICAO_COORDS = new Map(); // ICAO -> {lat, lon}
  let ICAO_INFO = new Map();  // ICAO -> {name, city, country}

  function loadCoordsFromStorage(){
    try{
      const raw = localStorage.getItem("wizz_icao_coords_v2");
      if (!raw) return false;
      const obj = JSON.parse(raw);
      ICAO_COORDS = new Map(Object.entries(obj.coords || obj).map(([k,v]) => [k, v]));
      if (obj.info) ICAO_INFO = new Map(Object.entries(obj.info).map(([k,v]) => [k, v]));
      return true;
    } catch(e){ return false; }
  }

  function saveCoordsToStorage(){
    try{
      const obj = { coords: Object.fromEntries(ICAO_COORDS.entries()), info: Object.fromEntries(ICAO_INFO.entries()) };
      localStorage.setItem("wizz_icao_coords_v2", JSON.stringify(obj));
    } catch(e){}
  }

  async function fetchOurAirportsCsv(){
    const urls = [
      "https://raw.githubusercontent.com/davidmegginson/ourairports-data/master/airports.csv",
      "https://cdn.jsdelivr.net/gh/davidmegginson/ourairports-data@master/airports.csv"
    ];
    let lastErr = null;
    for (const u of urls){
      try{
        const r = await fetch(u, { cache: "no-store" });
        if (!r.ok) throw new Error("HTTP " + r.status);
        return await r.text();
      } catch(e){ lastErr = e; }
    }
    throw lastErr || new Error("Failed to download OurAirports dataset.");
  }

  // Minimal CSV splitter that respects quotes for the fields we need
  function splitCsvLine(line){
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i=0; i<line.length; i++){
      const ch = line[i];
      if (ch === '"'){
        if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ){
        out.push(cur); cur = "";
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  async function ensureCoordsForIcaos(icaos){
    // Load cache
    if (!ICAO_COORDS.size) loadCoordsFromStorage();

    const missing = [];
    for (const icao of icaos){
      if (ICAO_COORDS.has(icao)) continue;
      // If mapping file already has coords, use them
      const m = STATION_MAP.get(icao);
      if (m && typeof m.lat === "number" && typeof m.lon === "number"){
        ICAO_COORDS.set(icao, { lat: m.lat, lon: m.lon });
        continue;
      }
      missing.push(icao);
    }
    if (!missing.length) return;

    // Download & parse OurAirports CSV once, then fill missing coords
    setStatus("buildStatus", `Resolving coordinates for ${missing.length} station(s) from public dataset…`);
    const csv = await fetchOurAirportsCsv();

    // Find column indices from header
    const lines = csv.split(/\r?\n/);
    if (!lines.length) throw new Error("OurAirports CSV empty.");
    const header = splitCsvLine(lines[0]).map(x => x.trim());
    const idxIdent = header.indexOf("ident");
    const idxLat = header.indexOf("latitude_deg");
    const idxLon = header.indexOf("longitude_deg");
    const idxName = header.indexOf("name");
    const idxMunicip = header.indexOf("municipality");
    const idxCountry = header.indexOf("iso_country");
    if (idxIdent < 0 || idxLat < 0 || idxLon < 0) throw new Error("Unexpected OurAirports CSV format.");

    const need = new Set(missing);
    // Parse line by line; stop early if all found
    for (let i=1; i<lines.length; i++){
      const line = lines[i];
      if (!line) continue;
      const cols = splitCsvLine(line);
      const ident = (cols[idxIdent] || "").toUpperCase();
      if (!need.has(ident)) continue;
      const lat = parseFloat(cols[idxLat]);
      const lon = parseFloat(cols[idxLon]);
      if (Number.isFinite(lat) && Number.isFinite(lon)){
        ICAO_COORDS.set(ident, { lat, lon });
      }
      // Info (best-effort)
      try{
        const name = idxName >= 0 ? (cols[idxName] || "").trim() : "";
        const city = idxMunicip >= 0 ? (cols[idxMunicip] || "").trim() : "";
        const country = idxCountry >= 0 ? (cols[idxCountry] || "").trim() : "";
        if (name || city || country) ICAO_INFO.set(ident, { name, city, country });
      } catch(e){}
      need.delete(ident);
      if (!need.size) break;
    }

    saveCoordsToStorage();
    const unresolved = [...need.values()];
    if (unresolved.length){
      setStatus("buildStatus", `Coordinates resolved, but ${unresolved.length} station(s) still missing (unknown ICAO in dataset).`);
    } else {
      setStatus("buildStatus", "Coordinates resolved.");
    }
  }

// --- Map (Leaflet)
  let MAP = null;
  let MAP_LAYER = null;

  function initMap(){
    if (MAP) return;
    const el = document.getElementById("map");
    if (!el || !window.L) return;
    MAP = L.map("map", { zoomControl: true, attributionControl: false }).setView([50, 10], 4);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 9 }).addTo(MAP);
    MAP_LAYER = L.layerGroup().addTo(MAP);
  }

  function markerColor(sev){
    if (sev === "RED") return "#ff4d6d";
    if (sev === "AMBER") return "#ffce3a";
    return "#2ee59d";
  }

  function renderMap(items){
    initMap();
    const box = document.getElementById("map");
    if (!MAP || !MAP_LAYER || !box) return;

    MAP_LAYER.clearLayers();
    const pts = [];

    for (const it of items){
      const st = stationLabel(it.icao);
      if (typeof st.lat !== "number" || typeof st.lon !== "number") continue;

      const color = markerColor(it.sev);
      const marker = L.circleMarker([st.lat, st.lon], {
        radius: 8,
        color: color,
        weight: 2,
        fillColor: color,
        fillOpacity: 0.55
      });

      const popup = `<div style="font-family: ui-sans-serif, system-ui; font-weight:800; margin-bottom:6px;">
          ${it.icao} — ${(st.station || "—")}
        </div>
        <div style="font-family: ui-monospace, Menlo, Consolas; font-size:12px; line-height:1.35;">
          <div><b>${it.sev}</b> / <b>${it.delayRisk}</b> (score ${it.score})</div>
          <div style="margin-top:6px;">${escapeHtml(it.time)}</div>
          <div style="margin-top:6px;">${escapeHtml((it.tags||[]).join(", "))}</div>
          <div style="margin-top:6px;">${escapeHtml(it.snippet || "")}</div>
        </div>`;
      marker.bindPopup(popup);
      marker.addTo(MAP_LAYER);
      pts.push([st.lat, st.lon]);
    }

    if (pts.length){
      const bounds = L.latLngBounds(pts);
      MAP.fitBounds(bounds.pad(0.35));
      setStatus("buildStatus", `Map updated: ${pts.length} marker(s) plotted.`);
    } else {
      MAP.setView([50, 10], 4);
      setStatus("buildStatus", "Map: no markers plotted (coordinates blocked/unresolved). If on a restricted network, external dataset or map tiles may be blocked.");
    }
  }

  function buildReadout(matched, synopsis, enroute){
    // 30–60s script, meeting-friendly.
    const reds = matched.filter(x => x.sev === "RED");
    const ambs = matched.filter(x => x.sev === "AMBER");
    const top = matched.slice(0, 6);

    const drivers = driversFromItems(matched);
    const baseHit = matched.filter(x => x.isBase).map(x => x.icao);
    const baseTxt = baseHit.length ? `Core base exposure includes ${uniq(baseHit).slice(0,6).join(", ")}. ` : "";

    const topTxt = top.length ? top.map(x => {
      const st = stationLabel(x.icao);
      const nm = st.station && st.station !== "—" ? ` (${st.station})` : "";
      return `${x.icao}${nm} ${x.sev}/${x.delayRisk}`;
    }).join(", ") : "no Wizz-matching hotspots at the selected threshold";

    const lines = [];
    lines.push(`Good morning. Here is today’s Wizz network weather and delay-risk overview based on the NOP Network Weather Assessment.`);
    lines.push(`Primary disruption drivers are: ${drivers}.`);
    if (reds.length){
      lines.push(`We have ${reds.length} RED hotspot(s) with high disruption potential. Please expect elevated reactionary delays and rotation knock-on risk.`);
    } else {
      lines.push(`No RED hotspots at the current threshold; disruption risk appears more localized rather than network-wide.`);
    }
    if (ambs.length){
      lines.push(`${ambs.length} AMBER station(s) indicate moderate operational variability and potential sequencing/capacity sensitivity.`);
    }
    lines.push(`${baseTxt}Top impacted stations to watch: ${topTxt}.`);
    // Add a short en-route cue if present
    const en = (enroute || "").replace(/\s+/g," ").trim();
    if (en && en.length > 80){
      lines.push(`En-route note: ${en.slice(0, 220)}${en.length > 220 ? "…" : ""}`);
    }
    // Add a short synopsis cue if present
    const syn = (synopsis || "").replace(/\s+/g," ").trim();
    if (syn && syn.length > 80){
      lines.push(`Synopsis cue: ${syn.slice(0, 240)}${syn.length > 240 ? "…" : ""}`);
    }
    lines.push(`Recommended posture: protect critical turns, prioritize base wave integrity where exposed, and monitor ATFM/capacity updates.`);
    return lines.join("\n\n");
  }

async function buildReport(){
    if (!WIZZ_ICAOS.size){
      setStatus("buildStatus", "Load your Wizz ICAO list first.");
      return;
    }
    if (!PDF_TEXT){
      setStatus("buildStatus", "Load the NOP PDF first.");
      return;
    }

    const minScore = parseInt($("minScore").value, 10) || 0;
    const maxHot = parseInt($("maxHot").value, 10) || 15;

    const synopsis = extractSynopsis(PDF_TEXT);
    const enroute = extractEnroute(PDF_TEXT);
    const overview = parseAirportsOverview(PDF_TEXT);

    // If Airports Overview is not extractable (often image/table), fall back to global ICAO/time parsing
    let overviewItems = overview;
    if (!overviewItems || !overviewItems.length){
      const globalItems = parseGlobalIcaoItems(PDF_TEXT);
      overviewItems = globalItems;
      // Surface this in diagnostics
      if (globalItems.length){
        setStatus("buildStatus", `Airports Overview not extracted as text; using global ICAO/time parsing (${globalItems.length} items).`);
      } else {
        setStatus("buildStatus", "Airports Overview not extracted as text; global ICAO/time parsing also found 0 items.");
      }
    }


    // Populate raw Airports Overview section (debug)
    const rawAO = extractSection(PDF_TEXT, "Airports Overview", ["En-route", "En route", "En-Route", "Disclaimer", "Legend", "Definitions"]);
    if (document.getElementById("airportsOverviewBox")) document.getElementById("airportsOverviewBox").textContent = rawAO || "—";
    if (rawAO && rawAO.trim().toLowerCase() === "airports overview") {
      document.getElementById("airportsOverviewBox").textContent = rawAO + "\n\n(Note: The PDF likely contains the Airports Overview as a non-text table/image. Using global ICAO/time parsing instead.)";
    }


    let matched = overviewItems
      .filter(it => WIZZ_ICAOS.has(it.icao))
      .map(it => ({ ...it, ...scoreAndTag(it) }))
      .filter(it => it.score >= minScore);

    matched.sort((a,b) => (b.score - a.score) || (a.icao.localeCompare(b.icao)));

    // Resolve airport info (name/city/country) + coordinates before building summaries/tables
    // This enables ICAO decoding (airport names) without manual mapping uploads.
    try{
      await ensureCoordsForIcaos(new Set(matched.map(x => x.icao)));
    } catch(e){
      console.warn(e);
    }


    // KPIs
    $("rGenerated").textContent = nowLocal();
    $("rSource").textContent = PDF_SOURCE || "—";
    $("rStations").textContent = String(WIZZ_ICAOS.size);
    $("rMapping").textContent = STATION_MAP.size ? `${STATION_MAP.size} mapped` : "none";

    const reds = matched.filter(x => x.sev === "RED").length;
    const ambs = matched.filter(x => x.sev === "AMBER").length;

    $("kMatched").textContent = String(matched.length);
    $("kRed").textContent = String(reds);
    $("kAmber").textContent = String(ambs);
    $("kDrivers").textContent = driversFromItems(matched);

    // Executive bullets
    const bullets = buildExecutiveBullets(matched);
    $("execBullets").innerHTML = bullets.map(b => `<li>${escapeHtml(b)}</li>`).join("");

    // Recommendations: customize if winter dominates
    const drv = driversFromItems(matched);
    const reco = [];
    if (drv.includes("Winter")){
      reco.push("Winter ops: confirm de-icing capacity, towing/stand plans, runway contamination monitoring; add turnaround buffers where exposed.");
    }
    if (drv.includes("Wind")){
      reco.push("Wind: monitor gust thresholds and crosswind exposure; anticipate approach/ground handling variability and capacity degradation.");
    }
    if (drv.includes("Convective")){
      reco.push("Convective: plan for holding and tactical reroutes; set diversion posture early for exposed islands/coastal stations.");
    }
    if (drv.includes("Low-vis")){
      reco.push("Low-visibility: expect LVO and sequencing constraints; protect first-wave departures.");
    }
    reco.push("Network: monitor ATFM/capacity; protect critical rotations; prioritize base wave integrity if bases are exposed.");
    $("recoBullets").innerHTML = reco.map(r => `<li>${escapeHtml(r)}</li>`).join("");

    // Hotspots table
    const tbody = $("hotBody");
    const top = matched.slice(0, maxHot);

    if (!top.length){
      tbody.innerHTML = `<tr><td colspan="8" style="color:rgba(233,238,252,0.70); font-weight:700;">No Wizz-matching items found (at this threshold).</td></tr>`;
    } else {
      tbody.innerHTML = top.map(it => {
        const cls = it.sev === "RED" ? "red" : (it.sev === "AMBER" ? "amb" : "gre");
        const riskCls = it.delayRisk === "HIGH" ? "red" : (it.delayRisk === "MEDIUM" ? "amb" : "gre");
        const drivers = it.tags.join(", ");
        const st = stationLabel(it.icao);
        const station = st.station !== "—" ? `${st.station}${st.country && st.country !== "—" ? " ("+st.country+")" : ""}` : "—";
        const baseBadge = it.isBase ? `<span class="badge base" style="margin-left:8px;">BASE</span>` : "";
        return `<tr>
          <td><span class="badge ${cls}">${escapeHtml(it.sev)}</span>${baseBadge}<div style="margin-top:6px;color:rgba(233,238,252,0.72);font-weight:800;">score ${it.score}</div></td>
          <td><span class="badge ${riskCls}">${escapeHtml(it.delayRisk)}</span></td>
          <td style="font-weight:950;">${escapeHtml(it.icao)}</td>
          <td style="font-family: var(--sans); font-weight: 750;">${escapeHtml(station)}</td>
          <td>${escapeHtml(it.time)}</td>
          <td>${escapeHtml(drivers || "—")}</td>
          <td style="max-width:380px; white-space: normal; font-family: var(--sans); font-weight: 700; line-height:1.35; color: rgba(233,238,252,0.86);">
            ${escapeHtml(explainSnippet(it.raw || it.snippet || ""))}
          </td>
          <td style="max-width:520px; white-space: normal; font-family: var(--sans); font-weight: 700; line-height:1.35;">
            ${escapeHtml(it.snippet || "")}
          </td>
        </tr>`;
      }).join("");
    }

    $("synopsisBox").textContent = synopsis || "—";
    $("enrouteBox").textContent = enroute || "—";

    // Map + management readout
    renderMap(top);
    if (document.getElementById("readoutBox")) document.getElementById("readoutBox").textContent = buildReadout(matched, synopsis, enroute);


    // Diagnostics
    const dbg = [
      `PDF loaded: ${PDF_LOADED_AT || "—"}`,
      `Overview items parsed: ${overviewItems.length}`,
      `Wizz ICAOs loaded: ${WIZZ_ICAOS.size}`,
      `Station mapping entries: ${STATION_MAP.size}`,
      `Core bases loaded: ${CORE_BASES.size}`,
      `Matched after threshold: ${matched.length}`,
      "",
      "If 'Overview items parsed' is 0, try PDF upload instead of URL (text extraction differences)."
    ].join("\n");
    $("debugBox").textContent = dbg;

    setStatus("buildStatus", "Report built.");
    try{ const a=document.getElementById("chkAutoMetar"); if (a && a.checked) fetchLiveMetars(); } catch(e){}

    // JS heartbeat
    if (document.getElementById("buildStatus")) document.getElementById("buildStatus").textContent = "Report built. (JS OK)";
  }

  // UI events
  $("btnUseSample").addEventListener("click", () => {
    WIZZ_ICAOS = new Set(SAMPLE_ICAOS);
    setStatus("icaoStatus", `Loaded sample: ${WIZZ_ICAOS.size} ICAO codes`);
    $("rStations").textContent = String(WIZZ_ICAOS.size);
  });

  $("btnLoadIcao").addEventListener("click", async () => {
    const f = $("icaoFile").files[0];
    if (!f){ setStatus("icaoStatus", "No TXT selected."); return; }
    const text = await readFileText(f);
    const list = parseIcaoText(text);
    WIZZ_ICAOS = new Set(list);
    setStatus("icaoStatus", `Loaded: ${WIZZ_ICAOS.size} ICAO codes`);
    $("rStations").textContent = String(WIZZ_ICAOS.size);
  });

  $("btnUseBaseSample").addEventListener("click", () => {
    CORE_BASES = new Set(SAMPLE_BASES);
    setStatus("baseStatus", `Loaded sample bases: ${CORE_BASES.size}`);
  });

  $("btnLoadBases").addEventListener("click", async () => {
    const f = $("baseFile").files[0];
    if (!f){ setStatus("baseStatus", "No TXT selected."); return; }
    const text = await readFileText(f);
    const list = parseIcaoText(text);
    CORE_BASES = new Set(list);
    setStatus("baseStatus", `Loaded bases: ${CORE_BASES.size}`);
  });

  $("btnClearMap").addEventListener("click", () => {
    STATION_MAP.clear();
    setStatus("mapStatus", "Mapping cleared.");
    $("rMapping").textContent = "none";
  });

  $("btnLoadMap").addEventListener("click", async () => {
    const f = $("mapFile").files[0];
    if (!f){ setStatus("mapStatus", "No mapping file selected."); return; }
    const name = (f.name || "").toLowerCase();
    const text = await readFileText(f);
    try{
      let entries = [];
      if (name.endsWith(".json")){
        const data = JSON.parse(text);
        entries = Array.isArray(data) ? data : [];
      } else {
        entries = parseCsvMapping(text);
      }
      STATION_MAP.clear();
      for (const e of entries){
        if (!e.icao) continue;
        STATION_MAP.set(e.icao.toUpperCase(), {
          name: e.name || "",
          country: e.country || "",
          type: (e.type || "").toUpperCase()
        });
      }
      setStatus("mapStatus", `Mapping loaded: ${STATION_MAP.size} entries`);
      $("rMapping").textContent = `${STATION_MAP.size} mapped`;
    } catch(err){
      console.error(err);
      setStatus("mapStatus", "Mapping load failed (invalid CSV/JSON).");
    }
  });

    $("btnLoadPdfFile").addEventListener("click", async () => {
    const f = $("pdfFile").files[0];
    if (!f){ setStatus("pdfStatus", "No PDF selected."); return; }
    setStatus("pdfStatus", "Parsing PDF…");
    try{
      const buf = await f.arrayBuffer();
      PDF_TEXT = await extractTextFromPdfArrayBuffer(buf);
      PDF_SOURCE = f.name;
      PDF_LOADED_AT = nowLocal();
      setStatus("pdfStatus", "PDF loaded from file.");
    } catch(e){
      console.error(e);
      setStatus("pdfStatus", "PDF parsing failed.");
    }
  });

  $("btnClearPdf").addEventListener("click", () => {
    PDF_TEXT = ""; PDF_SOURCE = ""; PDF_LOADED_AT = null;
    setStatus("pdfStatus", "No PDF loaded.");
    $("synopsisBox").textContent = "—";
    $("enrouteBox").textContent = "—";
    $("debugBox").textContent = "Ready.";
  });
  if ($("btnBuild")) $("btnBuild").addEventListener("click", buildReport);
  if ($("btnFetchMetar")) $("btnFetchMetar").addEventListener("click", fetchLiveMetars);
  if ($("btnToggleMetarPaste")) $("btnToggleMetarPaste").addEventListener("click", () => {
    const w = document.getElementById("metarPasteWrap");
    if (w) w.style.display = (w.style.display === "none" || !w.style.display) ? "block" : "none";
  });
  if ($("btnUsePastedMetar")) $("btnUsePastedMetar").addEventListener("click", usePastedMetars);
  if ($("btnClearMetar")) $("btnClearMetar").addEventListener("click", () => {
    const ta = document.getElementById("metarPaste");
    if (ta) ta.value = "";
    const tb = document.getElementById("metarTbody");
    if (tb) tb.innerHTML = '<tr><td colspan="9" style="opacity:.7;">No METAR loaded.</td></tr>';
    const st = document.getElementById("metarStatus");
    if (st) st.textContent = "—";
  });

  if ($("btnCopy")) $("btnCopy").addEventListener("click", copyMeetingSummary);
  if ($("btnCopilot")) $("btnCopilot").addEventListener("click", copyCopilotPrompt);
  // Modal (clipboard fallback) wiring
  if ($("btnCloseModal")) $("btnCloseModal").addEventListener("click", closeCopyModal);
  if ($("copyModalBackdrop")) $("copyModalBackdrop").addEventListener("click", closeCopyModal);
  if ($("btnSelectAll")) $("btnSelectAll").addEventListener("click", () => { const t=$("copyModalText"); if (t){ t.focus(); t.select(); } });
  if ($("btnCopyModal")) $("btnCopyModal").addEventListener("click", async () => { const t=$("copyModalText"); const ok = await tryCopyText(t ? t.value : ""); setStatus("buildStatus", ok ? "Copied from copy window." : "Copy failed: select all and press Ctrl+C."); });
  if ($("btnPrint")) $("btnPrint").addEventListener("click", () => window.print());
  if ($("btnDocx")) $("btnDocx").addEventListener("click", exportDocx);
  if ($("btnPptx")) $("btnPptx").addEventListener("click", exportPptx);
  if ($("btnAutoLoad")) $("btnAutoLoad").addEventListener("click", autoLoadFromRepo);
  // Auto-load repo files on startup (best-effort)
  (async () => { try { await autoLoadFromRepo(); } catch(e){} })();

  // Ensure modal controls are wired after DOM is fully parsed
  window.addEventListener("DOMContentLoaded", () => {
    if ($("btnCloseModal")) $("btnCloseModal").addEventListener("click", closeCopyModal);
    if ($("copyModalBackdrop")) $("copyModalBackdrop").addEventListener("click", closeCopyModal);
    if ($("btnSelectAll")) $("btnSelectAll").addEventListener("click", () => { const t=$("copyModalText"); if (t){ t.focus(); t.select(); } });
    if ($("btnCopyModal")) $("btnCopyModal").addEventListener("click", async () => {
      const t=$("copyModalText");
      const ok = await tryCopyText(t ? t.value : "");
      setStatus("buildStatus", ok ? "Copied from copy window." : "Copy failed: select all and press Ctrl+C.");
    });
  });

  // Auto-run if query params request it
  (async () => {
    const q = getQueryParams();
    
    if (q.autoload) await autoLoadFromRepo();
    if (q.autobuild) buildReport();
  })();


  // Auto-load helper (GitHub Pages / same-origin)
  async function tryFetchText(path){
    const r = await fetch(path, { cache: "no-store" });
    if (!r.ok) return null;
    return await r.text();
  }

  async function autoLoadFromRepo(){
    // ICAO list
    try{
      const icaoTxt = await tryFetchText("./wizz_icaos.txt");
      if (icaoTxt){
        const list = parseIcaoText(icaoTxt);
        WIZZ_ICAOS = new Set(list);
        setStatus("icaoStatus", `Auto-loaded: ${WIZZ_ICAOS.size} ICAO codes from wizz_icaos.txt`);
        $("rStations").textContent = String(WIZZ_ICAOS.size);
      } else {
        setStatus("icaoStatus", "Auto-load: wizz_icaos.txt not found in repo root.");
      }
    } catch(e){
      console.error(e);
      setStatus("icaoStatus", "Auto-load: failed to fetch wizz_icaos.txt (check GitHub Pages URL and file location).");
    }

    // Station mapping: prefer CSV, else JSON
    try{
      let mapTxt = await tryFetchText("./wizz_station_map.csv");
      let used = "wizz_station_map.csv";
      if (!mapTxt){
        mapTxt = await tryFetchText("./wizz_station_map.json");
        used = "wizz_station_map.json";
      }
      if (mapTxt){
        let entries = [];
        if (used.endsWith(".json")){
          const data = JSON.parse(mapTxt);
          entries = Array.isArray(data) ? data : [];
        } else {
          entries = parseCsvMapping(mapTxt);
        }
        STATION_MAP.clear();
        for (const e of entries){
          if (!e.icao) continue;
          STATION_MAP.set(String(e.icao).toUpperCase(), {
            name: e.name || "",
            country: e.country || "",
            type: (e.type || "").toUpperCase()
          });
        }
        setStatus("mapStatus", `Auto-loaded mapping: ${STATION_MAP.size} entries from ${used}`);
        $("rMapping").textContent = `${STATION_MAP.size} mapped`;
      } else {
        setStatus("mapStatus", "Auto-load: no station mapping file found (optional).");
      }
    } catch(e){
      console.error(e);
      setStatus("mapStatus", "Auto-load: mapping fetch/parse failed (check CSV/JSON format).");
    }

    // Bases
    try{
      const baseTxt = await tryFetchText("./wizz_core_bases.txt");
      if (baseTxt){
        const list = parseIcaoText(baseTxt);
        CORE_BASES = new Set(list);
        setStatus("baseStatus", `Auto-loaded bases: ${CORE_BASES.size} from wizz_core_bases.txt`);
      } else {
        setStatus("baseStatus", "Auto-load: wizz_core_bases.txt not found (optional).");
      }
    } catch(e){
      console.error(e);
      setStatus("baseStatus", "Auto-load: bases fetch failed (optional).");
    }
  }

  // Query string helper: ?pdf=<url>  and ?autoload=1&autobuild=1
  function getQueryParams(){
    const p = new URLSearchParams(window.location.search);
    return {
      pdf: p.get("pdf") || "",
      autoload: p.get("autoload") === "1",
      autobuild: p.get("autobuild") === "1",
    };
  }




  // ===== Live METAR cross-check (v8.6) =====
  function getAffectedIcaosFromHotspots(){
    const rows = Array.from(document.querySelectorAll("#hotBody tr"));
    const icaos = [];
    for (const tr of rows){
      const t = (tr.innerText || "").toUpperCase();
      const m = t.match(/\b[A-Z]{4}\b/);
      if (m) icaos.push(m[0]);
    }
    return uniq(icaos);
  }

  function forecastSignalsForIcao(icao){
    // Use drivers + snippet from the matched item (NOP PDF).
    const item = (LAST_MATCHED || []).find(x => x.icao === icao);
    const drivers = (item && item.drivers) ? String(item.drivers).toUpperCase() : "";
    const snip = (item && item.snippet) ? String(item.snippet).toUpperCase() : "";
    const sig = new Set();

    // Driver-based signals
    if (drivers.includes("WIND")) sig.add("WIND");
    if (drivers.includes("LOW") && drivers.includes("VIS")) sig.add("LOW VIS");
    if (drivers.includes("CONVECT")) sig.add("CONVECTIVE");
    if (drivers.includes("WINTER") || drivers.includes("ICE") || drivers.includes("SN") || drivers.includes("FZRA")) sig.add("WINTER");

    // Snippet-based (TAF/METAR tokens)
    if (/\b(FG|FZFG|BR)\b/.test(snip)) sig.add("FOG/BR");
    if (/\b(FZRA|FZDZ)\b/.test(snip)) sig.add("FREEZING PRECIP");
    if (/\bSN\b/.test(snip)) sig.add("SNOW");
    if (/\bTS\b/.test(snip) || /\bTSRA\b/.test(snip) || /\bCB\b/.test(snip)) sig.add("TS/CB");
    if (/\bRA\b/.test(snip) || /\bSHRA\b/.test(snip)) sig.add("RAIN/SH");

    return Array.from(sig);
  }

  function parseMetarLine(line){
    const s = (line || "").trim();
    const m = s.match(/^([A-Z]{4})\s+(.*)$/);
    if (!m) return null;
    const icao = m[1];
    const rest = m[2];

    const wind = (rest.match(/\b(?:VRB|\d{3})\d{2,3}(?:G\d{2,3})?KT\b/) || [])[0] || "—";

    let vis = "—";
    const visSM = rest.match(/\b(\d{1,2})SM\b/);
    const visM = rest.match(/\b(9999|\d{4})\b/);
    if (visSM) vis = visSM[0];
    else if (visM) vis = visM[1];

    const wxTokens = rest.match(/\b(\+|\-)?(TSRA|TS|RA|SN|SG|GR|GS|FZRA|FZDZ|DZ|SHRA|SHSN|SHGS|BR|FG|HZ)\b/g);
    const wx = wxTokens ? Array.from(new Set(wxTokens)).join(" ") : "—";

    let ceil = "—";
    const ceilM = rest.match(/\b(VV|BKN|OVC)\d{3}\b/g);
    if (ceilM && ceilM.length) ceil = ceilM[0];

    const time = (rest.match(/\b\d{6}Z\b/) || [])[0] || "—";

    return { icao, time, wind, vis, wx, ceil, raw: s };
  }

  function metarFlags(raw){
    raw = (raw || "").toUpperCase();
    let gust = 0;
    const g = raw.match(/G(\d{2,3})KT/);
    if (g) gust = parseInt(g[1],10) || 0;

    let windSpd = 0;
    const w = raw.match(/\b(?:VRB|\d{3})(\d{2,3})(?:G\d{2,3})?KT\b/);
    if (w) windSpd = parseInt(w[1],10) || 0;

    let visM = null;
    const vm = raw.match(/\b(9999|\d{4})\b/);
    if (vm){
      visM = (vm[1] === "9999") ? 9999 : (parseInt(vm[1],10) || null);
    }

    const hasFG = /\bFG\b/.test(raw) || /\bFZFG\b/.test(raw);
    const hasBR = /\bBR\b/.test(raw);
    const hasFZ = /\bFZRA\b/.test(raw) || /\bFZDZ\b/.test(raw);
    const hasSN = /\bSN\b/.test(raw) || /\bSHSN\b/.test(raw);
    const hasTS = /\bTS\b/.test(raw) || /\bTSRA\b/.test(raw);
    const hasCB = /\bCB\b/.test(raw);

    return { gust, windSpd, visM, hasFG, hasBR, hasFZ, hasSN, hasTS, hasCB };
  }

  function evaluateForecastVsMetar(signals, metar){
    const sig = new Set((signals || []).map(s => String(s).toUpperCase()));
    const f = metarFlags(metar.raw || "");

    const badges = [];

    // Low visibility
    if (sig.has("LOW VIS") || sig.has("FOG/BR")){
      if (f.visM !== null && f.visM <= 1500) badges.push({t:`Low vis confirmed (${f.visM}m)`, c:"bad"});
      else if (f.hasFG || f.hasBR) badges.push({t:"Fog/BR present", c:"warn"});
      else badges.push({t:"Low vis not observed", c:"ok"});
    }

    // Wind
    if (sig.has("WIND")){
      if (f.gust >= 35) badges.push({t:`Strong gusts (${f.gust}kt)`, c:"bad"});
      else if (f.gust >= 25 || f.windSpd >= 25) badges.push({t:`Elevated wind (${(f.gust || f.windSpd)}kt)`, c:"warn"});
      else badges.push({t:"Wind OK", c:"ok"});
    }

    // Convective
    if (sig.has("CONVECTIVE") || sig.has("TS/CB")){
      if (f.hasTS) badges.push({t:"TS observed", c:"bad"});
      else if (f.hasCB) badges.push({t:"CB reported", c:"warn"});
      else badges.push({t:"No TS/CB in METAR", c:"ok"});
    }

    // Winter
    if (sig.has("WINTER") || sig.has("SNOW") || sig.has("FREEZING PRECIP")){
      if (f.hasFZ) badges.push({t:"Freezing precip observed", c:"bad"});
      else if (f.hasSN) badges.push({t:"Snow observed", c:"warn"});
      else badges.push({t:"No wintry precip in METAR", c:"ok"});
    }

    if (!badges.length) return '<span class="badge muted">No evaluation rule</span>';
    return badges.map(b => `<span class="badge ${b.c}">${b.t}</span>`).join(" ");
  }

  function renderMetarTable(metarMap){
    const tb = document.getElementById("metarTbody");
    const st = document.getElementById("metarStatus");
    if (!tb) return;

    const icaos = getAffectedIcaosFromHotspots();
    if (!icaos.length){
      tb.innerHTML = '<tr><td colspan="9" style="opacity:.7;">No affected airports in the current view.</td></tr>';
      if (st) st.textContent = "No affected airports to compare.";
      return;
    }

    const rows = [];
    let ok=0, warn=0, bad=0, missing=0;

    for (const icao of icaos){
      const metar = metarMap[icao] || null;
      const sig = forecastSignalsForIcao(icao);
      const sigHtml = sig.length ? sig.map(s => `<span class="badge muted">${escapeHtml(s)}</span>`).join(" ") : '<span class="badge muted">—</span>';

      if (!metar){
        missing += 1;
        rows.push(`<tr>
          <td class="mono">${icao}</td>
          <td>${sigHtml}</td>
          <td>—</td><td>—</td><td>—</td><td>—</td><td>—</td>
          <td><span class="badge warn">No METAR</span></td>
          <td class="mono" style="opacity:.7;">—</td>
        </tr>`);
        continue;
      }

      const evalHtml = evaluateForecastVsMetar(sig, metar);
      if (evalHtml.includes("bad")) bad += 1
      else if (evalHtml.includes("warn")) warn += 1
      else ok += 1

      rows.push(`<tr>
        <td class="mono">${icao}</td>
        <td>${sigHtml}</td>
        <td class="mono">${metar.time}</td>
        <td class="mono">${metar.wind}</td>
        <td class="mono">${metar.vis}</td>
        <td class="mono">${metar.wx}</td>
        <td class="mono">${metar.ceil}</td>
        <td>${evalHtml}</td>
        <td class="mono">${escapeHtml(metar.raw)}</td>
      </tr>`);
    }

    tb.innerHTML = rows.join("") || '<tr><td colspan="9" style="opacity:.7;">No METAR loaded.</td></tr>';
    if (st) st.textContent = `METAR compare: ${ok} OK · ${warn} WATCH · ${bad} CONFIRMS · ${missing} missing`;
  }

  
  async function fetchLiveMetars(){
    const st = document.getElementById("metarStatus");
    const icaos = getAffectedIcaosFromHotspots();
    if (st) st.textContent = "Fetching live METARs from OGIMET…";
    if (!icaos.length){
      if (st) st.textContent = "No affected airports to fetch.";
      return;
    }

    // OGIMET getmetar returns CSV: ICAOIND,YEAR,MONTH,DAY,HOUR,MIN,REPORT (undecoded METAR).
    const now = new Date();
    const endStr = fmtOgimetTime(now);
    const beginStr = fmtOgimetTime(new Date(now.getTime() - 3*60*60*1000));

    const useProxy = true; // auto-fallback (GitHub Pages/browser CORS)
    const map = {};
    let okCount = 0;

    async function fetchText(url){
      try{
        const r = await fetch(url, { cache:"no-store" });
        if (!r.ok) throw new Error("HTTP " + r.status);
        return await r.text();
      } catch(e){
        if (!useProxy) throw e;
        const purl = "https://api.allorigins.win/raw?url=" + encodeURIComponent(url);
        const r2 = await fetch(purl, { cache:"no-store" });
        if (!r2.ok) throw new Error("Proxy HTTP " + r2.status);
        return await r2.text();
      }
    }

    function parseOgimetCsv(txt){
      const lines = (txt || "").split(/\r?\n/).map(x => x.trim()).filter(Boolean);
      const recs = [];
      for (const line of lines){
        if (/^ICAOIND,/i.test(line)) continue; // header
        // Split into 7 fields max; report may contain commas (rare) so join remainder
        const parts = line.split(",");
        if (parts.length < 7) continue;
        const icao = (parts[0] || "").trim().toUpperCase();
        const yr = parseInt(parts[1],10); const mo = parseInt(parts[2],10); const da = parseInt(parts[3],10);
        const hh = parseInt(parts[4],10); const mm = parseInt(parts[5],10);
        let report = parts.slice(6).join(",").trim();
        // remove optional quotes
        if (report.startsWith('"') && report.endsWith('"')) report = report.slice(1,-1);
        report = report.replace(/^(METAR|SPECI)\s+/i, "").trim();
        if (report && !/^[A-Z]{4}\s/.test(report)) report = (icao + " " + report);
        const tkey = ((yr||0)*100000000 + (mo||0)*1000000 + (da||0)*10000 + (hh||0)*100 + (mm||0));
        recs.push({icao, tkey, report});
      }
      return recs;
    }

    async function fetchOne(icao){
      const url = `https://www.ogimet.com/cgi-bin/getmetar?icao=${encodeURIComponent(icao)}&begin=${beginStr}&end=${endStr}&lang=eng&header=yes`;
      const txt = await fetchText(url);
      const recs = parseOgimetCsv(txt).filter(r => r.icao === icao);
      if (!recs.length) return null;
      recs.sort((a,b)=>a.tkey-b.tkey);
      const latest = recs[recs.length-1];
      const met = parseMetarLine(latest.report);
      return met;
    }

    // Concurrency limit (be gentle to OGIMET)
    const limit = Math.min(3, icaos.length);
    let idx = 0;
    async function worker(){
      while(idx < icaos.length){
        const i = idx++;
        const icao = icaos[i];
        try{
          const met = await fetchOne(icao);
          if (met){
            map[icao] = met;
            okCount += 1;
          }
        } catch(e){
          // ignore per-station failures
          console.warn("OGIMET fetch failed for " + icao, e);
        }
      }
    }
    await Promise.all(Array.from({length: limit}, ()=>worker()));

    renderMetarTable(map);
    if (st) st.textContent = `Loaded ${okCount} METAR(s) for ${icaos.length} affected airport(s) via OGIMET (with proxy fallback).`;
    if (okCount === 0 && st){
      st.textContent = "No METAR retrieved (network/CORS/proxy blocked). Use “Paste METARs instead”.";
    }
  }

  function fmtOgimetTime(d){
    const z = (n) => String(n).padStart(2,"0");
    return d.getUTCFullYear() + z(d.getUTCMonth()+1) + z(d.getUTCDate()) + z(d.getUTCHours()) + z(d.getUTCMinutes());
  }


  function usePastedMetars(){
    const ta = document.getElementById("metarPaste");
    const st = document.getElementById("metarStatus");
    const txt = ta ? ta.value : "";
    const lines = txt.split(/\r?\n/).map(x => x.trim()).filter(Boolean);
    const map = {};
    for (const line of lines){
      const m = parseMetarLine(line);
      if (m) map[m.icao] = m;
    }
    renderMetarTable(map);
    if (st) st.textContent = `Loaded ${Object.keys(map).length} METAR(s) from pasted text.`;
  }
</script>

  <!-- Copy / prompt modal (clipboard fallback) -->
  <div id="copyModal" class="modal" aria-hidden="true">
    <div class="modalBackdrop" id="copyModalBackdrop"></div>
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="copyModalTitle">
      <div class="modalHead">
        <div>
          <div id="copyModalTitle" class="modalTitle">Copy window</div>
          <div class="modalSub">If clipboard is blocked, select all and press Ctrl+C.</div>
        </div>
        <button class="btn" id="btnCloseModal">Close</button>
      </div>
      <textarea id="copyModalText" spellcheck="false"></textarea>
      <div class="modalActions">
        <button class="btn primary" id="btnCopyModal">Copy to clipboard</button>
        <button class="btn" id="btnSelectAll">Select all</button>
      </div>
    </div>
  </div>

</body>
</html
      <div class="card" style="margin-top:12px;">
        <h4>NOP forecast vs live METAR (affected airports only)</h4>
        <div class="hint">
          This section compares what the NOP PDF indicates (drivers + snippet/TAF-like text) against the latest observed METAR.
          If live fetch is blocked by your network/CORS, paste METAR lines instead.
        </div>

        <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">
          <button class="btn" id="btnFetchMetar">Fetch live METARs</button>
          <button class="btn" id="btnToggleMetarPaste">Paste METARs instead</button>
          <label style="display:flex; align-items:center; gap:8px; font-weight:800; opacity:.9;">
            <input type="checkbox" id="chkAutoMetar" checked />
            Auto-run after “Build report”
          </label>
          <div class="status" id="metarStatus" style="flex:1 1 auto;">—</div>
        </div>

        <div id="metarPasteWrap" style="display:none; margin-top:10px;">
          <label>Paste raw METAR lines (one per line)</label>
          <textarea id="metarPaste" style="width:100%; min-height:120px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:rgba(9,12,20,0.92); color:rgba(233,238,252,0.95); font-family:var(--mono); padding:12px;"></textarea>
          <div class="row" style="margin-top:10px; gap:10px;">
            <button class="btn primary" id="btnUsePastedMetar">Use pasted METARs</button>
            <button class="btn" id="btnClearMetar">Clear</button>
          </div>
        </div>

        <div class="table" style="margin-top:12px;">
          <table>
            <thead>
              <tr>
                <th>ICAO</th>
                <th>Forecast signals (NOP)</th>
                <th>Observed (METAR time)</th>
                <th>Wind</th>
                <th>Vis</th>
                <th>WX</th>
                <th>Ceiling</th>
                <th>Evaluation</th>
                <th>Raw METAR</th>
              </tr>
            </thead>
            <tbody id="metarTbody">
              <tr><td colspan="9" style="opacity:.7;">No METAR loaded.</td></tr>
            </tbody>
          </table>
        </div>
      </div>

>